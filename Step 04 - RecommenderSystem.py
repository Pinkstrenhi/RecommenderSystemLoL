import csv
import pandas as pd

def CreateCSV(filePath,fieldnames):
    with open(filePath, mode="w",encoding='utf-8', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(fieldnames)
def UpdateCSV(csvPath,write):
    with open(csvPath, mode="a",encoding='utf-8', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(write)
def ExitApplication():
    print("\nExiting the application...")
    exit()
def ExceptionPrint(content):
    print("*"*printFormatLine)
    print(f"\n--> {content}\n")
    print("*"*printFormatLine)

# For analysis
directory = r"path = where you want to save your recommended data (add / at the end of the path)"
# Exemple: 
# directory = r"/home/eloisa.oliveira/Área de Trabalho/Recommended/"

source = r"path = .csv file where you saved the final data"
# Exemple:
# sourceTrain = r"/home/eloisa.oliveira/Área de Trabalho/Data/finalData.csv
df = pd.read_csv(source)

individualPosition = "individualPosition"
championName = "championName"
win = "win"
matchId = "matchId"

printFormatLine = 60
commandStart = "Start"
commandExit = "Exit"

# To keep asking player and role until user exit the application
inicialization = input("Start or Exit?: ")
inicialization = inicialization.capitalize()

# To catch inputs that are not Start or Exit
try:
    if inicialization == commandStart:
        while inicialization != commandExit:
            print("-"*printFormatLine)
            
            role = input("Insert the player-role: ")
            role = role.upper()
            if role == commandExit:
                ExitApplication()
    
            champion = input("\nInsert the name of the enemy champion: ")
            champion = champion.capitalize()
            if champion == commandExit:
                ExitApplication()
            
            # Creates a .csv file with data separated per role
            csvName = f"dataSeparatedPerRole_{role}.csv"
            CreateCSV(directory + csvName,[matchId,individualPosition,championName,win])
            
            for i in range(len(df)):
                if df[individualPosition][i] == role:
                    UpdateCSV(directory + csvName,[df[matchId][i],
                                                               df[individualPosition][i],
                                                               df[championName][i],
                                                               df[win][i]])
            
            # Read the separated per role data 
            dfRole = pd.read_csv(directory + csvName)
            
            # Filter only the matches where the enemy champion has a win outcome equal to False
            # Matches where the enemy player lost the match with the inputed champion
            dataFiltered = dfRole[dfRole[championName].str.contains(champion, case = False)]
            
            matchIdAll = dataFiltered[matchId].tolist()
            dfFinal = dfRole[dfRole[matchId].isin(matchIdAll)]
            
            csvNameRole = f"dataSeparatedPerRoleAndChampion_{role}_{champion}.csv"
            
            dfFinal.to_csv(directory + csvNameRole,index = False)
            
            try:
                # To check the most common combination 
                # Where the inputed player has a win outcome of False
                # Which champion has more matches with win outcome of True (Count)
                winChampion = dfFinal[(dfFinal[championName] == champion) & (dfFinal[win] == False)]
                winOutcomeTrue = dfFinal[dfFinal[win] == True]
                
                dfMerged = pd.merge(winChampion, winOutcomeTrue, on = matchId)
                
                # "championName_y" is generated by pd.merge
                countCombinations = dfMerged[f"{championName}_y"].value_counts()
                countCombinationsMostCommon = countCombinations.idxmax()
                
                print(f"\nRecommended Champion: {countCombinationsMostCommon}")
                
                print("-"*printFormatLine)
                print(f"\nMost recommended champion to play against {champion} in role {role} is {countCombinationsMostCommon}\n")
                print(f"\nAmount of combination:\n{countCombinations}\n\n")
                print("-"*printFormatLine)
            
            except KeyError:
                print("\n")
                ExceptionPrint("KeyError: Not in base, try another input")
            except ValueError:
                print("\n")
                ExceptionPrint("ValueError: Not in base, try another input")
            except Exception:
                ExceptionPrint("An Error occurred")
            if inicialization == commandExit:
                break
    else:
        ExitApplication()
except Exception:
    ExceptionPrint("Error: Not a valid input")

